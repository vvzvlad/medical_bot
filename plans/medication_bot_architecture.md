# Архитектура Telegram-бота для управления приемом медикаментов

Разработать архитектуру и формальную спецификацию Telegram-бота для управления приемом медикаментов со следующими требованиями:


Компоненты:
- Telegram Bot API клиент для обработки входящих сообщений и отправки уведомлений
- Модуль хранения данных с использованием JSON-файлов для персистентности расписаний приема медикаментов каждого пользователя
- Планировщик задач для мониторинга времени приема и генерации напоминаний
- Интеграция с Groq LLM API для обработки естественноязыковых команд редактирования расписания
- Менеджер конфигурации для загрузки токенов бота и LLM из переменных окружения (.env файл или системные переменные)

ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ

Модуль управления данными:
Структура JSON для каждого пользователя должна содержать user_id, список медикаментов с полями: название препарата, дозировка, время приема (массив временных меток), статус последнего приема (timestamp принятия или null), message_id последнего напоминания. Реализовать CRUD операции для медикаментов пользователя с атомарной записью в файл.

Система напоминаний:
Фоновый процесс проверяет каждую минуту все расписания пользователей. При наступлении времени приема или обнаружении пропущенных приемов формируется уведомление. Логика формирования сообщения: собрать все медикаменты, время приема которых наступило но они не были отмечены как принятые, отсортировать по времени назначения. Текст сообщения в формате "Надо принять:\n[Название препарата] [дозировка]\n[Название препарата] [дозировка]". Inline-клавиатура с кнопками для каждого препарата, callback_data содержит user_id и medication_id. При отправке нового напоминания удалять предыдущее сообщение используя сохраненный message_id. Повторные напоминания отправляются каждый час для непринятых медикаментов.

Обработка подтверждения приема:
При нажатии inline-кнопки обработать callback_query, записать timestamp приема для соответствующего медикамента, удалить кнопку принятого препарата из сообщения. Если все препараты из уведомления приняты, удалить сообщение полностью или заменить текстом подтверждения.

Интеграция с LLM для редактирования расписания:

У бота нет команд вообще, все взаимодействие происходит через текстовые сообщения.
Есть такие "команды", сообщения ллм, которые что-то делают:
1)мне надо принимать аспирин в 19:00 (если нет дозы, то ее не записываем) — команда добавления (add)
2)я больше не принимаю аспирин — команда удаления (delete)
3)я теперь принимаю аспирин в 19:00 и 21:00 — команда изменения времени (time_change)
4)я принимаю аспирин 200 мг — команда изменения дозы (dose_change)
5)моя часовая зона москва — команда изменения часового пояса (timezone_change)
6)что я принимаю — команда вывода расписания (list)
7)я принял аспирин — команда приема раньше времени (done)

Парсинг естествнного языка происходит так: берется сообщение пользователя и отпрвляется в ллм с системным промтом, который говорит, что нужно понять, какой тип команды из вариантов выше пользователь хочет выполнить.
Тип команды возвращается в формате json, например:
```json
{
    "command_type": "add",
}
Потом в зависимости от типа команды, формируется еще промпт для ллм, который будет выполнять команду с описанием того, как надо парсить команды и что выводить в ответв в json. 

наприер для команды add промпт будет такой:
ты ассистент приема медикаментов, пользователь хочет добавить новый медикамент в расписание. Он написал сообщение: {user_message}. Определи название медикамента, время приема и дозировку. Если дозировка не указана, то не указывай ее в ответе. Ответ должен быть в формате json.

а для команды time_change: (в schedule есть уникальные ключи для каждого медикамента)
ты ассистент приема медикаментов, пользователь хочет изменить время приема медикамента. 
вот текущее распиасние польвателя: {schedule}. Он написал сообщение: {user_message}. определи, для какого именно медикамента он хочет поменять время приема, и если оно понятное — например, один аспирин в 19:00 — то верни ключ медикамента и его новое время. Если пользователь говорит "я принимаю аспирин в 19", а у него есть несколько аспиринов, то верни сообщение о том, что нужно уточнить: "вы принимаете аспирин в 19:00 и аспирин в 21:00, уточните, какой именно вы хотите изменить". В первом случает логика программы должна поменять расписание, а во втором - отправить пользователю сообщение от ллм о том, что нужно уточнить, написать "аспирин, который я принимаю в 19 часов я теперь принимаю в 16 часов"
 Ответ должен быть в формате json.

 Такая же логика для команды delete — если под определение попадает несколько медикаментов, то нужно уточнить, какой именно. Если пользователь пишет "я теперь вообще не принимаю аспирин", то нужно удалить все аспирины. (предостумотреть удаление нескольких медикаментов по ключам)

 такая же логика для dose_change — если непонятно что изменяет пользователь, то нужно уточнить, какой именно медикамент он хочет изменить.

 для команды timezone_change во втором запросе ллм подается список городов и их временные зоны, и если пользователь говорит что его временная зона москва, то ллм возвращает таймзону для москвы. если в списке городов-временных ±зонах нет нужного города, то нужно ллм говорит что не знает такого города и просит отправить таймзону в со смещением относительно UTC, типа +7 или -3. т.е. в промпте модели надо написать, что пользователь может написать таймзону в виде смещения относительно UTC, а может название города

для list второй вызов ллм не нужен, если первый запрос вернул "command_type": "list", то мы просто выводим расписание в формате:
Вы принимаете: 
1)в 10:00 — аспирин 200 мг 
2)в 12:00 и и 18:00 — парацетамол 400 мг  
...

для команды done — на вход второму вызову ллм подается расписание и сообщение пользователя с просбой вернуть список ключей медикаментов, которые пользователь мог принять — если пользователь говорит "я принял парацетамол", а пользователь принимает его несколько раз, то ллм возвращает два ключа, а если аспирин в расписании пользователеля один — то один ключ. бизнес-логика смотрит на возврат ллм, и если ключ один — то просто помечает этот ключ как принятый, а если несколько — то смотрит какой из них ближе по времени к текущему времени и помечает его как принятый.



Изоляция данных пользователей:
Каждый user_id имеет отдельный JSON Все операции чтения/записи изолированы по user_id.

Конфигурация:
Использовать библиотеку python-dotenv или аналог для загрузки переменных TELEGRAM_BOT_TOKEN и GROQ_API_KEY из .env файла с fallback на системные переменные окружения.

Обработка ошибок: логирование всех ошибок API, graceful degradation при недоступности LLM, retry логика для Telegram API.

### Технологический стек
- **Python 3.11+**
- **aiogram 3.x** - Telegram Bot API
- **python-dotenv** - управление конфигурацией
- **loguru** - структурированное логирование
- **httpx** - асинхронные HTTP-запросы к Groq API
- **asyncio** - асинхронная обработка

---

### Описание компонентов

#### 1. Telegram Bot Layer
- **Telegram API Client**: Обработка входящих сообщений и отправка уведомлений
- **Message Handler**: Обработка всех текстовых сообщений через LLM (кроме `/list`)
- **Callback Handler**: Обработка нажатий inline-кнопок подтверждения приема

#### 2. Business Logic Layer
- **Schedule Manager**: CRUD операции над расписаниями медикаментов
- **Notification Manager**: Формирование и отправка напоминаний
- **LLM Integration**: Обработка всех естественноязыковых команд (добавление, изменение, удаление)

#### 3. Data Layer
- **Data Manager**: Абстракция работы с хранилищем
- **File Storage**: JSON-файлы для персистентности

#### 4. Background Services
- **Scheduler Task**: Фоновый процесс проверки времени приема и отправки напоминаний

---


```bash
# Telegram Bot
TELEGRAM_BOT_TOKEN=your_token_here

# Groq LLM
GROQ_API_KEY=your_api_key_here
GROQ_MODEL=openai/gpt-oss-120b
GROQ_TIMEOUT=30
GROQ_MAX_RETRIES=3

# Application
LOG_LEVEL=INFO
DATA_DIR=data/users
SCHEDULER_INTERVAL_SECONDS=60
REMINDER_REPEAT_INTERVAL_HOURS=1

# Timezone (default for new users)
DEFAULT_TIMEZONE=Europe/Moscow
```

---