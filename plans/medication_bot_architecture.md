# Архитектура Telegram-бота для управления приемом медикаментов

## Описание проекта

Разработать архитектуру и формальную спецификацию Telegram-бота для управления приемом медикаментов со следующими требованиями.

---

## Технологический стек

- **Python 3.11+**
- **aiogram 3.x** - Telegram Bot API
- **python-dotenv** - управление конфигурацией
- **loguru** - структурированное логирование
- **httpx** - асинхронные HTTP-запросы к Groq API
- **asyncio** - асинхронная обработка

---

## Архитектура системы

### Основные компоненты

- Telegram Bot API клиент для обработки входящих сообщений и отправки уведомлений
- Модуль хранения данных с использованием JSON-файлов для персистентности расписаний приема медикаментов каждого пользователя
- Планировщик задач для мониторинга времени приема и генерации напоминаний
- Интеграция с Groq LLM API для обработки естественноязыковых команд редактирования расписания
- Менеджер конфигурации для загрузки токенов бота и LLM из переменных окружения (.env файл или системные переменные)

### Описание слоев

#### 1. Telegram Bot Layer
- **Telegram API Client**: Обработка входящих сообщений и отправка уведомлений
- **Message Handler**: Обработка всех текстовых сообщений через LLM (кроме `/list`)
- **Callback Handler**: Обработка нажатий inline-кнопок подтверждения приема

#### 2. Business Logic Layer
- **Schedule Manager**: CRUD операции над расписаниями медикаментов
- **Notification Manager**: Формирование и отправка напоминаний
- **LLM Integration**: Обработка всех естественноязыковых команд (добавление, изменение, удаление)

#### 3. Data Layer
- **Data Manager**: Абстракция работы с хранилищем
- **File Storage**: JSON-файлы для персистентности

#### 4. Background Services
- **Scheduler Task**: Фоновый процесс проверки времени приема и отправки напоминаний

---

## Функциональные требования

### 1. Модуль управления данными

Структура JSON для каждого пользователя должна содержать:
- `user_id`
- Список медикаментов с полями:
  - Название препарата
  - Дозировка
  - Время приема (массив временных меток)
  - Статус последнего приема (timestamp принятия или null)
  - `message_id` последнего напоминания

Реализовать CRUD операции для медикаментов пользователя с атомарной записью в файл.

### 2. Система напоминаний

Фоновый процесс проверяет каждую минуту все расписания пользователей. При наступлении времени приема или обнаружении пропущенных приемов формируется уведомление.

**Логика формирования сообщения:**
- Собрать все медикаменты, время приема которых наступило, но они не были отмечены как принятые
- Отсортировать по времени назначения
- Текст сообщения в формате:
  ```
  Надо принять:
  [Название препарата] [дозировка]
  [Название препарата] [дозировка]
  ```

**Inline-клавиатура:**
- Кнопки для каждого препарата
- `callback_data` содержит `user_id` и `medication_id`

**Управление сообщениями:**
- При отправке нового напоминания удалять предыдущее сообщение используя сохраненный `message_id`
- Повторные напоминания отправляются каждый час для непринятых медикаментов

### 3. Обработка подтверждения приема

При нажатии inline-кнопки:
- Обработать `callback_query`
- Записать timestamp приема для соответствующего медикамента
- Удалить кнопку принятого препарата из сообщения
- Если все препараты из уведомления приняты, удалить сообщение полностью или заменить текстом подтверждения

### 4. Интеграция с LLM для редактирования расписания

#### Общий принцип работы

У бота нет команд вообще, все взаимодействие происходит через текстовые сообщения.

#### Типы команд

1. **add** - добавление медикамента
   - Пример: "мне надо принимать аспирин в 19:00"
   - Примечание: если нет дозы, то ее не записываем

2. **delete** - удаление медикамента
   - Пример: "я больше не принимаю аспирин"

3. **time_change** - изменение времени приема
   - Пример: "я теперь принимаю аспирин в 19:00 и 21:00"

4. **dose_change** - изменение дозы
   - Пример: "я принимаю аспирин 200 мг"

5. **timezone_change** - изменение часового пояса
   - Пример: "моя часовая зона москва"

6. **list** - вывод расписания
   - Пример: "что я принимаю"

7. **done** - прием раньше времени
   - Пример: "я принял аспирин"

8. **unknown** - неизвестная команда
   - Пример: "привет"

#### Двухэтапный процесс обработки команд

**Этап 1: Определение типа команды**

Сообщение пользователя отправляется в LLM с системным промптом, который определяет тип команды из вариантов выше.

Тип команды возвращается в формате JSON:
```json
{
    "command_type": "add"
}
```

**Этап 2: Выполнение команды**

В зависимости от типа команды формируется второй промпт для LLM с описанием того, как надо парсить команды и что выводить в ответ в JSON.

#### Детальное описание обработки команд

##### Тут везде краткие примерные промпты (для продакшена надо расширить их примерами)

**Команда `add`:**

: "ты ассистент приема медикаментов, пользователь хочет добавить новый медикамент в расписание. Он написал сообщение: {user_message}. Определи название медикамента, время приема и дозировку. Если дозировка не указана, то не указывай ее в ответе. Ответ должен быть в формате json."

**Команда `time_change`:**

Промпт: "ты ассистент приема медикаментов, пользователь хочет изменить время приема медикамента. Вот текущее расписание пользователя: {schedule}. Он написал сообщение: {user_message}. Определи, для какого именно медикамента он хочет поменять время приема, и если оно понятное — например, один аспирин в 19:00 — то верни ключ медикамента и его новое время. Если пользователь говорит "я принимаю аспирин в 19", а у него есть несколько аспиринов, то верни сообщение о том, что нужно уточнить: "вы принимаете аспирин в 19:00 и аспирин в 21:00, уточните, какой именно вы хотите изменить". В первом случае логика программы должна поменять расписание, а во втором - отправить пользователю сообщение от LLM о том, что нужно уточнить, написать "аспирин, который я принимаю в 19 часов я теперь принимаю в 16 часов". Ответ должен быть в формате json."

Примечание: в schedule есть уникальные ключи для каждого медикамента.

**Команда `delete`:**

Логика аналогична `time_change`:
- Если под определение попадает несколько медикаментов, то нужно уточнить, какой именно
- Если пользователь пишет "я теперь вообще не принимаю аспирин", то нужно удалить все аспирины
- Предусмотреть удаление нескольких медикаментов по ключам

**Команда `dose_change`:**

Логика аналогична `time_change`:
- Если непонятно что изменяет пользователь, то нужно уточнить, какой именно медикамент он хочет изменить

**Команда `timezone_change`:**

Во втором запросе LLM подается список городов и их временные зоны:
- Если пользователь говорит что его временная зона москва, то LLM возвращает таймзону для москвы
- Если в списке городов-временных зонах нет нужного города, то LLM говорит что не знает такого города и просит отправить таймзону со смещением относительно UTC, типа +7 или -3
- В промпте модели надо написать, что пользователь может написать таймзону в виде смещения относительно UTC, а может название города

**Команда `list`:**

Второй вызов LLM не нужен. Если первый запрос вернул `"command_type": "list"`, то просто выводим расписание в формате:
```
Вы принимаете: 
1) в 10:00 — аспирин 200 мг 
2) в 12:00 и 18:00 — парацетамол 400 мг
...
```

**Команда `done`:**

На вход второму вызову LLM подается расписание и сообщение пользователя с просьбой вернуть список ключей медикаментов, которые пользователь мог принять:
- Если пользователь говорит "я принял парацетамол", а пользователь принимает его несколько раз, то LLM возвращает два ключа
- Если аспирин в расписании пользователя один — то один ключ

Бизнес-логика смотрит на возврат LLM:
- Если ключ один — то просто помечает этот ключ как принятый
- Если несколько — то смотрит какой из них ближе по времени к текущему времени и помечает его как принятый

**Команда `unknown`:**
во втором вызове ллм присылается сообщение пользователя и просьба написать сообщение что команда пользователя не распознана

### 5. Изоляция данных пользователей

- Каждый `user_id` имеет отдельный JSON
- Все операции чтения/записи изолированы по `user_id`

### 6. Конфигурация

Использовать библиотеку python-dotenv или аналог для загрузки переменных `TELEGRAM_BOT_TOKEN` и `GROQ_API_KEY` из .env файла с fallback на системные переменные окружения.

### 7. Обработка ошибок

- Логирование всех ошибок API
- Graceful degradation при недоступности LLM
- Retry логика для Telegram API

---

## Конфигурация окружения

```bash
# Telegram Bot
TELEGRAM_BOT_TOKEN=your_token_here

# Groq LLM
GROQ_API_KEY=your_api_key_here
GROQ_MODEL=openai/gpt-oss-120b
GROQ_TIMEOUT=30
GROQ_MAX_RETRIES=3

# Application
LOG_LEVEL=INFO
DATA_DIR=data/users
SCHEDULER_INTERVAL_SECONDS=60
REMINDER_REPEAT_INTERVAL_HOURS=1

# Timezone (default for new users)
DEFAULT_TIMEZONE=Europe/Moscow
```

---
