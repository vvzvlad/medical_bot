# Архитектура Telegram-бота для управления приемом медикаментов

## Описание проекта

Разработать архитектуру и формальную спецификацию Telegram-бота для управления приемом медикаментов со следующими требованиями.

---

## Технологический стек

- **Python 3.11+**
- **aiogram 3.x** - Telegram Bot API
- **python-dotenv** - управление конфигурацией
- **loguru** - структурированное логирование
- **httpx** - асинхронные HTTP-запросы к Groq API
- **asyncio** - асинхронная обработка

---

## Архитектура системы

### Основные компоненты

- Telegram Bot API клиент для обработки входящих сообщений и отправки уведомлений
- Модуль хранения данных с использованием JSON-файлов для персистентности расписаний приема медикаментов каждого пользователя
- Планировщик задач для мониторинга времени приема и генерации напоминаний
- Интеграция с Groq LLM API для обработки естественноязыковых команд редактирования расписания
- Менеджер конфигурации для загрузки токенов бота и LLM из переменных окружения (.env файл или системные переменные)

### Описание слоев

#### 1. Telegram Bot Layer
- **Telegram API Client**: Обработка входящих сообщений и отправка уведомлений
- **Message Handler**: Обработка всех текстовых сообщений через LLM (кроме `/list`)
- **Callback Handler**: Обработка нажатий inline-кнопок подтверждения приема

#### 2. Business Logic Layer
- **Schedule Manager**: CRUD операции над расписаниями медикаментов
- **Notification Manager**: Формирование и отправка напоминаний
- **LLM Integration**: Обработка всех естественноязыковых команд (добавление, изменение, удаление)

#### 3. Data Layer
- **Data Manager**: Абстракция работы с хранилищем
- **File Storage**: JSON-файлы для персистентности

#### 4. Background Services
- **Scheduler Task**: Фоновый процесс проверки времени приема и отправки напоминаний

---

## Функциональные требования

### 0. Первый запуск и онбординг пользователя

При первом взаимодействии с новым пользователем бот должен:
- Отправлять приветственное сообщение с кратким описанием возможностей
- Предложить установить часовой пояс
- Сообщение генерируется LLM каждый раз

### 1. Модуль управления данными

#### Структура данных

Каждый пользователь имеет отдельный JSON файл со следующей структурой:

```json
{
  "user_id": 123456789,
  "timezone_offset": "+03:00",
  "medications": [
    {
      "id": 1,
      "name": "Аспирин",
      "dosage": "200 мг",
      "time": "10:00",
      "last_taken": 1735372800,
      "reminder_message_id": 12345
    },
    {
      "id": 2,
      "name": "Аспирин",
      "dosage": "200 мг",
      "time": "18:00",
      "last_taken": null,
      "reminder_message_id": null
    }
  ]
}
```

**Пояснения к структуре:**
- `user_id` - идентификатор пользователя Telegram
- `timezone_offset` - смещение часового пояса относительно UTC (например, "+03:00", "-05:00")
- `medications` - массив медикаментов
  - `id` - инкрементный идентификатор медикамента (генерируется при каждом запросе к LLM)
  - `name` - название препарата
  - `dosage` - дозировка в свободном формате (200 мг, 2 таблетки, 1 ложка и т.д.) или null
  - `time` - время приема в формате "HH:MM" в локальном часовом поясе пользователя
  - `last_taken` - Unix timestamp последнего приема или null
  - `reminder_message_id` - ID последнего отправленного напоминания или null

**Особенности хранения:**
- Если пользователь принимает один медикамент несколько раз в день, создаются отдельные объекты с одинаковым названием
- Время приема (`time`) хранится в локальном часовом поясе пользователя в формате "HH:MM"
- При проверке расписания система сравнивает текущее время (с учетом `timezone_offset`) с `time` каждого медикамента
- Если текущее время >= `time` и `last_taken` либо null, либо был в предыдущий день, то отправляется напоминание
- История приема не хранится, только timestamp последнего приема (`last_taken`)
- Дозировка может быть любым текстом или отсутствовать

Реализовать CRUD операции для медикаментов пользователя с атомарной записью в файл.

### 2. Система напоминаний

Фоновый процесс проверяет каждую минуту все расписания пользователей. При наступлении времени приема или обнаружении пропущенных приемов формируется уведомление.

**Логика формирования сообщения:**
- Собрать все медикаменты, время приема которых наступило, но они не были отмечены как принятые
- Если при проверке времени приема обнаружено, что уже нужно принять несколько медикаментов, они комбинируются в одно сообщение
- Отсортировать по времени назначения
- Текст сообщения в формате:
  ```
  Надо принять:
  [Название препарата] [дозировка]
  [Название препарата] [дозировка]
  ```

**Inline-клавиатура:**
- Кнопки под сообщением о необходимости принять препарат по кнопке для каждого препарата с названием медикамента. удаляем кнопки, если на них нажали и значит препарат принят
- `callback_data` содержит `user_id` и `medication_id`

**Управление сообщениями:**
- При отправке нового напоминания удалять предыдущее сообщение используя сохраненный `message_id`
- Повторные напоминания отправляются каждый час для непринятых медикаментов
- Если пришло время приема такого же медикамента (по названию, без учета дозы), удалить предыдущее напоминание

**Обработка пропущенных приемов:**
- Продолжать напоминать каждый час до тех пор, пока пользователь не отметит прием
- Если пришло время приема такого же медикамента (по названию), удалить предыдущее напоминание и считать что прием был

### 3. Обработка подтверждения приема

При нажатии inline-кнопки:
- Обработать `callback_query`
- Записать timestamp приема для соответствующего медикамента
- Удалить кнопку принятого препарата из сообщения
- Если все препараты из уведомления приняты, удалить сообщение полностью или заменить текстом подтверждения

**Обработка изменений расписания:**
- Если пользователь изменил расписание (например, удалил медикамент), а напоминание уже отправлено, перестать напоминать о старом
- Считать что этого приема не было и дальше работать с новым расписанием

### 4. Интеграция с LLM для редактирования расписания

#### Общий принцип работы

У бота нет команд вообще, все взаимодействие происходит через текстовые сообщения.

**Язык интерфейса:** Только русский язык.

#### Типы команд

1. **add** - добавление медикамента
   - Пример: "мне надо принимать аспирин в 19:00"
   - Примечание: если нет дозы, то ее не записываем

2. **delete** - удаление медикамента
   - Пример: "я больше не принимаю аспирин"

3. **time_change** - изменение времени приема
   - Пример: "я теперь принимаю аспирин в 19:00 и 21:00"

4. **dose_change** - изменение дозы
   - Пример: "я принимаю аспирин 200 мг"

5. **timezone_change** - изменение часового пояса
   - Пример: "моя часовая зона москва" или "я в москве"

6. **list** - вывод расписания
   - Пример: "что я принимаю", "напиши расписание", "мои препараты"

7. **done** - прием раньше времени
   - Пример: "я принял аспирин"

8. **unknown** - неизвестная команда
   - Пример: "привет"
   - Обработка: во втором вызове LLM присылается сообщение пользователя и просьба написать сообщение что команда пользователя не распознана

#### Двухэтапный процесс обработки команд

**Этап 1: Определение типа команды**

Сообщение пользователя отправляется в LLM с системным промптом, который определяет тип команды из вариантов выше.

**Системный промпт для определения типа команды:**
```
Ты ассистент для управления приемом медикаментов. Пользователь отправил сообщение.
Определи тип команды из следующих вариантов:
- add: добавление нового медикамента
- delete: удаление медикамента
- time_change: изменение времени приема
- dose_change: изменение дозировки
- timezone_change: изменение часового пояса
- list: показать текущее расписание
- done: отметить прием медикамента раньше времени
- unknown: неизвестная команда

Сообщение пользователя: {user_message}

Верни ответ в формате JSON: {"command_type": "тип_команды"}
```

Тип команды возвращается в формате JSON:
```json
{
    "command_type": "add"
}
```

**Этап 2: Выполнение команды**

В зависимости от типа команды формируется второй промпт для LLM с описанием того, как надо парсить команды и что выводить в ответ в JSON.

**Обработка ошибок LLM:**
- Если LLM возвращает некорректные данные или не может распарсить команду, отправлять пользователю сообщение об ошибке с просьбой переформулировать

#### Детальное описание обработки команд

##### Примечание: Тут везде краткие примерные промпты (для продакшена надо расширить их примерами)

**Команда `add`:**

Промпт: "ты ассистент приема медикаментов, пользователь хочет добавить новый медикамент в расписание. Он написал сообщение: {user_message}. Определи название медикамента, время приема и дозировку. Если дозировка не указана, то не указывай ее в ответе. Ответ должен быть в формате json."

Формат ответа:
```json
{
  "medication_name": "Аспирин",
  "times": ["19:00"],
  "dosage": "200 мг"
}
```

Если дозировка не указана:
```json
{
  "medication_name": "Аспирин",
  "times": ["19:00"]
}
```

**Команда `time_change`:**

Промпт: "ты ассистент приема медикаментов, пользователь хочет изменить время приема медикамента. Вот текущее расписание пользователя: {schedule}. Он написал сообщение: {user_message}. Определи, для какого именно медикамента он хочет поменять время приема, и если оно понятное — например, один аспирин в 19:00 — то верни ключ медикамента и его новое время. Если пользователь говорит "я принимаю аспирин в 19", а у него есть несколько аспиринов, то верни сообщение о том, что нужно уточнить: "вы принимаете аспирин в 19:00 и аспирин в 21:00, уточните, какой именно вы хотите изменить". В первом случае логика программы должна поменять расписание, а во втором - отправить пользователю сообщение от LLM о том, что нужно уточнить, написать "аспирин, который я принимаю в 19 часов я теперь принимаю в 16 часов". Ответ должен быть в формате json."

Примечание: в schedule есть уникальные инкрементные ID для каждого медикамента (генерируются при каждом запросе к LLM).

Формат ответа (успешный случай):
```json
{
  "status": "success",
  "medication_id": 1,
  "new_times": ["19:00", "21:00"]
}
```

Формат ответа (требуется уточнение):
```json
{
  "status": "clarification_needed",
  "message": "Вы принимаете аспирин в 19:00 и аспирин в 21:00, уточните, какой именно вы хотите изменить"
}
```

**Команда `delete`:**

Логика аналогична `time_change`:
- Если под определение попадает несколько медикаментов, то нужно уточнить, какой именно
- Если пользователь пишет "я теперь вообще не принимаю аспирин", то нужно удалить все аспирины
- Предусмотреть удаление нескольких медикаментов по ID

Формат ответа (успешный случай, один медикамент):
```json
{
  "status": "success",
  "medication_ids": [1]
}
```

Формат ответа (успешный случай, все медикаменты с одним названием):
```json
{
  "status": "success",
  "medication_ids": [1, 3, 5]
}
```

Формат ответа (требуется уточнение):
```json
{
  "status": "clarification_needed",
  "message": "Вы принимаете аспирин в 19:00 и аспирин в 21:00, уточните, какой именно вы хотите удалить"
}
```

**Команда `dose_change`:**

Логика аналогична `time_change`:
- Если непонятно что изменяет пользователь, то нужно уточнить, какой именно медикамент он хочет изменить

Формат ответа (успешный случай):
```json
{
  "status": "success",
  "medication_id": 1,
  "new_dosage": "300 мг"
}
```

Формат ответа (требуется уточнение):
```json
{
  "status": "clarification_needed",
  "message": "Вы принимаете аспирин в 19:00 и аспирин в 21:00, уточните, для какого именно вы хотите изменить дозировку"
}
```

**Команда `timezone_change`:**

Во втором запросе LLM подается список городов и их временные зоны в формате "город:смещение":
- Если пользователь говорит что его временная зона москва, то LLM возвращает смещение для москвы
- Если в списке городов-временных зонах нет нужного города, то LLM говорит что не знает такого города и просит отправить таймзону со смещением относительно UTC, типа +7 или -3
- В промпте модели надо написать, что пользователь может написать таймзону в виде смещения относительно UTC, а может название города
- Летнее/зимнее время не используется, оперируем только смещением

**Список городов и временных зон:**
```

Калининград: +02:00
Москва: +03:00
Санкт-Петербург: +03:00
Тверь: +03:00
Брянск: +03:00
Воронеж: +03:00
Курск: +03:00
Белгород: +03:00
Смоленск: +03:00
Ярославль: +03:00
Кострома: +03:00
Вологда: +03:00
Архангельск: +03:00
Мурманск: +03:00
Нижний Новгород: +03:00
Киров: +03:00
Волгоград: +03:00
Саратов: +04:00
Астрахань: +04:00
Ульяновск: +04:00
Екатренбург: +05:00
Пермь: +05:00
Оренбург: +05:00
Тюмень: +05:00
Челябинск: +05:00
Омск: +06:00
Новосибирск: +07:00
Томск: +07:00
Кемерово: +07:00
Барнаул: +07:00
Краснояск: +07:00
Иркутск: +08:00
Улан-Удэ: +08:00
Чита: +09:00
Якутск: +09:00
Владивосток: +10:00
Хабаровск: +10:00
Магадан: +11:00
Петропавловск-Камчатский: +12:00
Киев (Украина): +02:00
Львов (Украина): +02:00
Харьков (Украина): +02:00
Кишинёв (Молдавия): +02:00
Минск (Беларусь): +03:00
Баку (Азербайджан): +04:00
Ереван (Армения): +04:00
Тбилиси (Грузия): +04:00
Ташкент (Узбекистан): +05:00
Бухара (Узбекистан): +05:00
Ашхабад (Туркменистан): +05:00
Душанбе (Таджикистан): +05:00
Актау (Казахстан): +05:00
Алматы (Казахстан): +06:00
Астана/Нур-Султан (Казахстан): +06:00
Бишкек (Кыргызстан): +06:00

Лиссабон (Португалия): +00:00
Лондон (Великобритания): +00:00
Дублин (Ирландия): +00:00
Мадрид (Испания): +01:00
Барселона (Испания): +01:00
Париж (Франция): +01:00
Марсель (Франция): +01:00
Лион (Франция): +01:00
Амстердам (Нидерланды): +01:00
Брюссель (Бельгия): +01:00
Люксембург: +01:00
Берлин (Германия): +01:00
Мюнхен (Германия): +01:00
Кёльн (Германия): +01:00
Цюрих (Швейцария): +01:00
Берн (Швейцария): +01:00
Вена (Австрия): +01:00
Прага (Чешская Республика): +01:00
Братислава (Словакия): +01:00
Варшава (Польша): +01:00
Краков (Польша): +01:00
Осло (Норвегия): +01:00
Стокгольм (Швеция): +01:00
Копенгаген (Дания): +01:00
Будапешт (Венгрия): +01:00
Любляна (Словения): +01:00
Загреб (Хорватия): +01:00
Белград (Сербия): +01:00
Рим (Италия): +01:00
Милан (Италия): +01:00
Венеция (Италия): +01:00
Вильнюс (Литва): +02:00
Рига (Латвия): +02:00
Таллинн (Эстония): +02:00
София (Болгария): +02:00
Бухарест (Румыния): +02:00
Афины (Греция): +02:00
Никосия (Кипр): +02:00
Хельсинки (Финляндия): +02:00
```

Формат ответа (успешный случай):
```json
{
  "status": "success",
  "timezone_offset": "+03:00"
}
```

Формат ответа (требуется уточнение):
```json
{
  "status": "clarification_needed",
  "message": "Я не знаю такого города. Пожалуйста, укажите часовой пояс в виде смещения относительно UTC, например +3 или -5"
}
```

**Команда `list`:**

Второй вызов LLM не нужен. Если первый запрос вернул `"command_type": "list"`, то просто выводим расписание в формате:
```
Вы принимаете:
1) в 10:00 — аспирин 200 мг
2) в 12:00 и 18:00 — парацетамол 400 мг
...
```

Время отображается с учетом часового пояса пользователя (конвертация из UTC).

**Команда `done`:**

На вход второму вызову LLM подается расписание и сообщение пользователя с просьбой вернуть список ID медикаментов, которые пользователь мог принять:
- Если пользователь говорит "я принял парацетамол", а пользователь принимает его несколько раз, то LLM возвращает несколько ID
- Если аспирин в расписании пользователя один — то один ID

Бизнес-логика смотрит на возврат LLM:
- Если ID один — то просто помечает этот медикамент как принятый
- Если несколько — то смотрит какой из них ближе по времени к текущему времени и помечает его как принятый

Формат ответа:
```json
{
  "medication_ids": [1, 3]
}
```

**Команда `unknown`:**

Во втором вызове LLM присылается сообщение пользователя и просьба написать сообщение что команда пользователя не распознана.

Формат ответа (примерный, генерируетс ллм каждый раз):
```json
{
  "message": "Извините, я не понял вашу команду. Попробуйте переформулировать или напишите 'что я принимаю' чтобы увидеть ваше расписание"
}
```

### 5. Изоляция данных пользователей

- Каждый `user_id` имеет отдельный JSON файл
- Все операции чтения/записи изолированы по `user_id`

### 6. Конфигурация

Использовать библиотеку python-dotenv или аналог для загрузки переменных `TELEGRAM_BOT_TOKEN` и `GROQ_API_KEY` из .env файла с fallback на системные переменные окружения.

### 7. Обработка ошибок и граничных случаев

#### Обработка ошибок API

- Логирование всех ошибок API
- Graceful degradation при недоступности LLM
- Retry логика для Telegram API

#### Граничные случаи

**Пользователь пытается добавить медикамент, который уже есть в расписании:**
- Разрешить добавление (могут быть разные дозы или время приема)

**Пользователь пытается удалить медикамент, которого нет в расписании:**
- Отправить сообщение "У вас нет такого медикамента в расписании"

**Пользователь отправляет сообщение, которое LLM не может распознать:**
- Отправить сообщение об ошибке с просьбой переформулировать

**Файл JSON пользователя поврежден:**
- Логировать ошибку
- Создать новый пустой файл для пользователя
- Уведомить пользователя о проблеме

**Telegram API возвращает ошибку при отправке сообщения:**
- Логировать ошибку
- Повторить попытку отправки (retry логика)
- Если не удалось после N попыток, пропустить это сообщение

**Groq API возвращает ошибку или таймаут:**
- Логировать ошибку
- Уведомить пользователя: "Произошла ошибка (тип ошибки) при обработке команды. Попробуйте еще раз"
- Если ошибка о нехватке средств на счету, то так и сказать

**Пользователь нажимает кнопку подтверждения приема для уже принятого медикамента:**
- Пказать уведомление "Вы уже отметили прием этого медикамента"

#### Уведомления о системных событиях

Уведомлять пользователя только о событиях, которые касаются его напрямую:
- Произошла ошибка при обработке команды
- LLM API недоступен

Не уведомлять о:
- Перезагрузке бота
- Внутренних логах и ошибках системы

### 8. Логирование

**Что логировать:**
- Все входящие сообщения от пользователей (с user_id)
- Все запросы к LLM и ответы
- Все изменения в расписаниях пользователей
- Все отправленные напоминания
- Все ошибки и исключения
- Время выполнения критических операций

**Формат логов:**
- Структурированные JSON логи
- Уровни: DEBUG, INFO, WARNING, ERROR, CRITICAL

### 9. Тестирование

**Типы тестов:**
- Unit тесты для бизнес-логики
- Тесты для проверки корректности парсинга команд
- Тесты для проверки системы напоминаний

### 10. Мониторинг и метрики

**Метрики для отслеживания:**
- Количество пользователей
- Количество отправленных напоминаний
- Количество запросов к LLM
- Количество ошибок API
- Время работы бота (uptime)
выводить их по скрытой команде(не показывается в предложенных командах) /stats
команда доступна любому пользователю


## Конфигурация окружения

```bash
# Telegram Bot
TELEGRAM_BOT_TOKEN=your_token_here

# Groq LLM
GROQ_API_KEY=your_api_key_here
GROQ_MODEL=openai/gpt-oss-120b
GROQ_TIMEOUT=30
GROQ_MAX_RETRIES=3

# Application
LOG_LEVEL=INFO
DATA_DIR=data/users
SCHEDULER_INTERVAL_SECONDS=60
REMINDER_REPEAT_INTERVAL_HOURS=1

# Timezone (default for new users)
DEFAULT_TIMEZONE_OFFSET=+03:00
```

---
